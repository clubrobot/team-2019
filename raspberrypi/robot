#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from argparse import ArgumentParser

from common.serialtalks import *
from common.components import Server, Manager
from common.geogebra import *
from common.roadmap import *
#from robots.beacons_manager import BeaconsManagement
#from daughter_cards.buttons import ButtonCard
#from robots.buttons_manager import ButtonGestureDemo, ButtonGestureMatch


DEV_MODE = True
MATCH_MODE = False

arduino_list = ['sensors', 'wheeledbase', 'power', 'display', 'modulescollector', 'mineralscollector', 'watershooter', 'watersorter']

def start(**args):
    import robots.Bornibus as Bornibus
    manager = Manager()
    Bornibus.start_match()
    pass

def start_approval(**args):
    pass

def dev_mode(args):
    m = Manager()
    m.connect()
    button_card = ButtonCard(m)
    screen = SevenSegments(m)
    wheeledbase = WheeledBase(m)
    button_gesture = ButtonGestureDemo(button_card, screen, m)
    while not button_gesture.exiting: time.sleep(0.2)
    m.disconnect()


def getuuid(args):
    talks = SerialTalks(args.port)
    try:
        talks.connect(args.timeout)
        uuid = talks.getuuid(args.timeout)
        if isinstance(uuid, str):
            print(uuid)
        else:
            raise ValueError('\'{}\' object is not a valid UUID'.format(type(uuid)))
    except KeyboardInterrupt:
        pass
    finally:
        talks.disconnect()


def showip(args):
    try:
        ssd.clear_messages()
        import subprocess
        ips = []
        wlan_up = False
        attempts = 0
        while not wlan_up and attempts < 10:
            proc = subprocess.run(['iwconfig', 'wlan0'], stdout=subprocess.PIPE)
            wifi_config = proc.stdout.strip().decode('utf8')
            if wifi_config.find("ESSID:\"") > -1:
                wlan_up = True
                time.sleep(5)
                proc = subprocess.run(['hostname', '-I'], stdout=subprocess.PIPE)
                ips = proc.stdout.strip().decode('utf8').split(" ")
            else:
                attempts += 1
                time.sleep(1)
        if wlan_up:
            [ssd.set_message(ip) for ip in ips]
        else:
            ssd.set_message("No Ip found ")
    except:
        pass


def getlogs(args):
    talks = SerialTalks(args.port)
    try:
        talks.connect(args.timeout)
        while True:
            sys.stdout.write(talks.getout())
            sys.stderr.write(talks.geterr())
    except KeyboardInterrupt:
        pass
    finally:
        talks.disconnect()


def server(args):
    srv = Server(password=args.password, size=args.size, start_match=start)
    while True:
        try:
            while not srv.full():
                srv.connect(None)
            srv.sleep_until_one_disconnected()

        except KeyboardInterrupt:
            srv.disconnect()
            break
        except Exception as e:
            sys.stderr.write('{}: {}\n'.format(type(e).__name__, e))
            continue

def stop(args):
    os.system("sudo kill `pidof python3`")


# Update arduino programs
def update(args):
    import subprocess

    # List all the arduino which should be updated
    if args.arduino != "all":
        arduinos_to_verify = [args.arduino]
    else:
        arduinos_to_verify = arduino_list

    arduinos_to_update = []

    # Verify if the code of the arduino changed since last update (can be forced)
    if not args.force:
        for arduino in arduinos_to_verify:
            arduino_path = os.path.dirname(os.path.realpath(__file__)) + '/../arduino/' + arduino
            gitdiff = subprocess.run(['/usr/bin/git', 'diff', '--quiet', '--exit-code', arduino_path])
            if gitdiff.returncode == 0:
                print(arduino + " up to date")
            else:
                arduinos_to_update += [arduino]

    else:
        arduinos_to_update = arduinos_to_verify

    # Git pull
    subprocess.run(['/usr/bin/git', 'pull', '-f'], stdout=subprocess.PIPE)

    # Execute make upload for the selected arduinos
    for arduino in arduinos_to_update:
        arduino_path = os.path.dirname(os.path.realpath(__file__)) + '/../arduino/' + arduino
        print("updating " + arduino)
        subprocess.run(['/usr/bin/make', 'upload_safe', '-C', arduino_path])


from robots.get_robot_name import *
import sys

no_server = ["server", "getuuid"]

if sys.argv[1] not in no_server:
    manager = Manager("127.0.0.1")
    manager.connect()
    if ROBOT_ID == BORNIBUS_ID:
        from robots.setup_bornibus import init_robot
        init_robot()
    if ROBOT_ID == R128_ID:
        from robots.setup_128 import init_robot
        init_robot()

parser = ArgumentParser()
subparsers = parser.add_subparsers()

getuuid_parser = subparsers.add_parser('getuuid')
getuuid_parser.add_argument('port', type=str)
getuuid_parser.add_argument('-t', '--timeout', type=float, default=10)
getuuid_parser.set_defaults(func=getuuid)

getlogs_parser = subparsers.add_parser('getlogs')
getlogs_parser.add_argument('port', type=str)
getlogs_parser.add_argument('-t', '--timeout', type=float, default=5)
getlogs_parser.set_defaults(func=getlogs)

server_parser = subparsers.add_parser('server')
server_parser.add_argument('-p', '--password', type=str, default=None)
server_parser.add_argument('-s', '--size', type=int, default=4)
server_parser.set_defaults(func=server)

showip_parser = subparsers.add_parser('showip')
showip_parser.set_defaults(func=showip)

start_parser = subparsers.add_parser('start')
start_parser.set_defaults(func=start)

start_approval_parser = subparsers.add_parser('start_approval')
start_approval_parser.set_defaults(func=start_approval)

dev_parser = subparsers.add_parser('dev_mode')
dev_parser.set_defaults(func=dev_mode)

update_parser = subparsers.add_parser('update')
update_parser.add_argument('arduino', type=str, default='all', choices=arduino_list + ['all'])
update_parser.add_argument('-f', '--force', action="store_true", required=False, default=False)
update_parser.set_defaults(func=update)

stop_parser = subparsers.add_parser('stop')
stop_parser.set_defaults(func=stop)


args = parser.parse_args()
args.func(args)
